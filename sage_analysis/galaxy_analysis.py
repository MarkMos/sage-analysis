"""

TODO
----
Split this up into smaller functions. Its ghastly as is.
Doc showing exactly how to generate non-default calc/plot functions.
Doc showing exactly how to generate non-default extra properties.
"plot_output_path" should be passed to "generate_plots".
Add more nuance to checking when/if SMF needs to be calculated.
Add "*args" to data class functions to allow them to pass a variable number of arguments.
Add extra tests to ensure that things are being logged when there are no galaxies present.
"""

import logging
import os
from typing import List, Dict, Union, Optional, Any, Tuple, Callable

import sage_analysis.example_calcs
import sage_analysis.example_plots

from sage_analysis.default_analysis_arguments import default_plot_toggles, default_galaxy_properties_to_analyse
from sage_analysis.utils import generate_func_dict, read_generic_sage_params
from sage_analysis.model import Model
from sage_analysis.sage_binary import SageBinaryData
try:
    from sage_analysis.sage_hdf5 import SageHdf5Data
except ImportError:
    print("h5py not found.  If you're reading in HDF5 output from SAGE, please install this package.")

import matplotlib
import numpy as np


logger = logging.getLogger(__name__)


class GalaxyAnalysis:

    def __init__(
        self,
        sage_parameter_fnames: List[str],
        plot_toggles: Optional[Dict[str, bool]] = None,
        sage_output_formats: Optional[List[str]] = None,
        labels: Optional[List[str]] = None,
        first_files_to_analyse: Optional[List[int]] = None,
        last_files_to_analyse: Optional[List[int]] = None,
        num_sage_output_files: Optional[List[int]] = None,
        output_format_data_classes: Optional[Dict[str, Any]] = None,
        random_seeds: Optional[List[int]] = None,
        history_redshifts: Optional[Dict[str, Union[List[float], str]]] = None,
        calculation_functions: Optional[Dict[str, Tuple[Callable, Dict[str, Any]]]] = None,
        plot_functions: Optional[Dict[str, Tuple[Callable, Dict[str, Any]]]] = None,
        galaxy_properties_to_analyse: Optional[Dict[str, Dict[str, Union[str, List[str]]]]] = None,
        plots_that_need_smf: Optional[List[str]] = None,
        IMFs: Optional[List[str]] = None,
    ):
        """
        sage_parameter_fnames : list of strings
            The name of the **SAGE** parameter files that are to be analysed. These are the ``.ini`` files used to
            generate the galaxy files. The length of this variable is equal to the number of models to be analysed.

        plot_toggles : dict [str, bool], optional
            Specifies which properties should be analysed and plotted.

            If not specified, uses
            .. code-block:: python

                default_plot_toggles = {
                    "SMF" : True,
                    "BMF" : True,
                    "GMF" : True,
                    "BTF" : True,
                    "sSFR" : True,
                    "gas_fraction" : True,
                    "metallicity" : True,
                    "bh_bulge" : True,
                    "quiescent" : True,
                    "bulge_fraction" : True,
                    "baryon_fraction" : True,
                    "reservoirs" : True,
                    "spatial" : True,
                    "SMF_history": False,
                    "SFRD_history": False,
                    "SMD_history": False,
                }

        sage_output_formats : list of strings, optional
            The output formats of each **SAGE** model being analysed.  Each value here **MUST** have a corresponding
            entry in ``output_format_data_classes``. The length of this variable is equal to the number of models to be
            analysed.

            If not specified, will use the ``OutputFormat`` entry from the respective **SAGE** parameter file.

        labels : list of strings, optional
            The labels to be used in the legend for each model.  The length of this variable is equal to the number of
            models to be analysed.

            If not specified, will use the ``FileNameGalaxies`` entry from the respective **SAGE** parameter file.

        first_files_to_analyse, last_files_to_analyse : list of ints, optional-ish
            The output **SAGE** files to be analysed.  This is an inclusive range, with the output files analyzed ranging
            from ``[first_file_to_analyse, last_file_to_analyse]`` for each model. The length of this variable is equal
            to the number of models to be analysed.

            If the corresponding entry in ``sage_output_format`` is ``sage_binary`` (whether passed explicitly or read from
            ``sage_file``), these two variables **MUST** be specified.  Otherwise, if not specified, will analyse **ALL**
            output HDF5 files.

        num_sage_output_files : list of ints, optional-ish
            Specifies the number of output files that were generated by running **SAGE**. This will generally be equal
            to the number of processors used to run **SAGE** and can be different to the range specified by
            ``[first_file_to_analyse, last_file_to_analyse]``.

            If the corresponding entry in ``sage_output_format`` is ``sage_binary`` (whether passed explicitly or read from
            ``sage_file``), this **MUST** be specified.  Otherwise, this variable is **NOT** used.

        output_format_data_classes : dict [string, class], optional
            A dictionary that maps the output format name to the corresponding data class. Each value in
            ``sage_output_formats`` **MUST** have an entry in this dictionary.

            If not specified, will use a default value
            ``output_format_data_classes = {"sage_binary":`` :py:class:`~sage_analysis.sage_binary.SageBinaryData` ``,
            "sage_hdf5":`` :py:class:`~sage_analysis.sage_binary.SageHdf5Data` ``}``.

        random_seeds : list of ints, optional
            The values to seed the random number generator for each model.  If the value is ``None``, then the
            generator is seeded using the ``np.random.seed()`` method. The length of this variable is equal to the
            number of models to be analysed.

            If not specified, uses ``None`` for each model (i.e., no predetermined seed).

        history_redshifts : dict [string, string or list of floats], optional
            Specifies which redshifts should be analysed for properties and plots that are tracked over time. The keys
            here **MUST** correspond to the keys in ``plot_toggles``. If the value of the entry is ``"All"``, then all
            snapshots will be analyzed. Otherwise, will search for the closest snapshots to the requested redshifts.

            If not specified, uses
            .. code-block:: python

            history_redshifts = {
                "SMF_history": "All",
                "SMD_history": "All",
                "SFRD_history": "All",
            }

        calculation_functions : dict [string, tuple(function, dict[string, variable])], optional
            A dictionary of functions that are used to compute the properties of galaxies being analysed.  Here, the string
            is the name of the plot toggle (e.g., ``"SMF"``), the value is a tuple containing the function itself (e.g.,
            ``calc_SMF()``), and another dictionary which specifies any optional keyword arguments to that function with
            keys as the name of variable (e.g., ``"calc_sub_populations"``) and values as the variable value (e.g.,
            ``True``).

            The functions in this dictionary are called for all files analyzed and **MUST** have a signature ``func(Model,
            gals, optional_keyword_arguments)``. This dict can be generated using
            :py:func:`~sage_analysis.utils.generate_func_dict`.

            If not specified, will use the functions found in :py:module:`~sage_analysis.example_calcs`, filtered to ensure
            that only those functions necessary to plot the plots specified by ``plot_toggles`` are run.

        plot_functions : dict [string, tuple(function, dict[string, variable])], optional
            A dictionary of functions that are used to plot the properties of galaxies being analysed.  Here, the string is
            the name of the function (e.g., ``"plot_SMF"``), the value is a tuple containing the function itself (e.g.,
            ``plot_SMF()``), and another dictionary which specifies any optional keyword arguments to that function with
            keys as the name of variable (e.g., ``"plot_sub_populations"``) and values as the variable value (e.g.,
            ``True``).

            The functions in this dictionary are called for all files analyzed and **MUST** have a signature ``func(Models,
            plot_output_path, plot_output_format, optional_keyword_arguments)``. This dict can be generated using
            :py:func:`~sage_analysis.utils.generate_func_dict`.

            If not specified, will use the functions found in :py:module:`~sage_analysis.example_plots`, filtered to ensure
            that only those functions necessary to plot the plots specified by ``plot_toggles`` are run.

        galaxy_properties_to_analyse : dict [string, dict[str, float or str or list of strings]], optional
            The galaxy properties that are used when running ``calculation_functions``. The properties initialized here
            will be accessible through ``model.properties["property_name"]``. This variable is a nested dictionary with
            the outer dictionary specifying the name of the bins (if the properties will be binned), or a unique name
            otherwise.

            The inner dictionary has a number of fields that depend upon the type of property.  We support properties
            being either binned against a property (e.g., the stellar or halo mass functions are binned on stellar/halo
            mass), plotted as x-vs-y scatter plots (e.g., specific star formation rate vs stellar mass for 1000
            galaxies), or as a single value (e.g., the stellar mass density).

            For binned against a property, the key/value pairs are:  ``"type": "binned"``, ``bin_low: The lower bound
            of the bin (float)``, ``bin_high: The upper bound of the bin (float)``, ``bin_width: The width of the bin
            (float)``, ``property_names: A list of strings denoting the properties to be initialised``. The bin values
            are all initialized as 0.0.

            For properties to be plotted as x-vs-y scatter plots, the key/value pairs are:  ``"type": "scatter"``,
            ``property_names: A list of strings denoting the properties to be initialised``. All properties are
            initialized as empty lists.

            For properties that are single values, the key/value pairs are:  ``"type": "single"``,
            ``property_names: A list of strings denoting the properties to be initialised``. All properties are
            initialized with a value of 0.0.

            If not specified, uses
            .. code-block:: python

            default_galaxy_properties_to_analyse = {
                "stellar_mass_bins": {
                    "type": "binned",
                    "bin_low": 8.0,
                    "bin_high": 12.0,
                    "bin_width": 0.1,
                    "property_names": [
                        "SMF", "red_SMF", "blue_SMF", "BMF", "GMF",
                        "centrals_MF", "satellites_MF", "quiescent_galaxy_counts",
                        "quiescent_centrals_counts", "quiescent_satellites_counts",
                        "fraction_bulge_sum", "fraction_bulge_var",
                        "fraction_disk_sum", "fraction_disk_var", "SMF_history",
                    ],
                },
                "halo_mass_bins": {
                    "type": "binned",
                    "bin_low": 10.0,
                    "bin_high": 14.0,
                    "bin_width": 0.1,
                    "property_names": ["fof_HMF"] + [f"halo_{component}_fraction_sum"
                        for component in ["baryon", "stars", "cold", "hot", "ejected", "ICS", "bh"]
                    ],
                },
                "scatter_properties": {
                    "type": "scatter",
                    "property_names": [
                        "BTF_mass", "BTF_vel", "sSFR_mass", "sSFR_sSFR",
                        "gas_frac_mass", "gas_frac", "metallicity_mass",
                        "metallicity", "bh_mass", "bulge_mass", "reservoir_mvir",
                        "reservoir_stars", "reservoir_cold", "reservoir_hot",
                        "reservoir_ejected", "reservoir_ICS", "x_pos",
                        "y_pos", "z_pos"
                    ],
                },
                "single_properties": {
                    "type": "single",
                    "property_names": ["SMD_history", "SFRD_history"],
                },
            }

        plots_that_need_smf : list of strings, optional
            The plot toggles that require the stellar mass function to be properly computed and analysed. For example,
            plotting the quiescent fraction of galaxies requires knowledge of the total number of galaxies. The strings
            here must **EXACTLY** match the keys in ``plot_toggles``.

            If not specified, uses a default value of ``["SMF", "quiescent", "bulge_fraction", "SMF_history"]``.

        IMFs : list of strings, optional, ``{"Chabrier", "Salpeter"}``
            The initial mass functions used during the analysis of the galaxies.  This is used to shift the
            observational data points. The length of this variable is equal to the number of models to be analysed.

            If not specified, uses a ``"Chabrier"`` IMF for each model.
        """

        # If the parameter file was passed as a string, cast to a list to keep consistent.
        if type(sage_parameter_fnames) == str:
            sage_parameter_fnames = [sage_parameter_fnames]

        num_models = len(sage_parameter_fnames)
        self._num_models = num_models

        if IMFs is None:
            IMFs = ["Chabrier"] * num_models

        if labels is None:
            labels = [None] * num_models

        if sage_output_formats is None:
            sage_output_formats = [None] * num_models

        if first_files_to_analyse is None:
            first_files_to_analyse = [None] * num_models

        if last_files_to_analyse is None:
            last_files_to_analyse = [None] * num_models

        if num_sage_output_files is None:
            num_sage_output_files = [None] * num_models

        if output_format_data_classes is None:
            output_format_data_classes = {"sage_binary": SageBinaryData, "sage_hdf5": SageHdf5Data}
        self._output_format_data_classes = output_format_data_classes

        if random_seeds is None:
            random_seeds = [None] * num_models

        if history_redshifts is None:
            history_redshifts = {
                "SMF_history": "All",
                "SMD_history": "All",
                "SFRD_history": "All",
            }
        self._history_redshifts = history_redshifts

        if plots_that_need_smf is None:
            plots_that_need_smf = ["SMF", "quiescent", "bulge_fraction", "SMF_history"]

        individual_model_parameters = [
            sage_parameter_fnames,
            IMFs,
            labels,
            sage_output_formats,
            first_files_to_analyse,
            last_files_to_analyse,
            num_sage_output_files,
            random_seeds,
        ]

        global_model_parameters = [
            history_redshifts,
            plots_that_need_smf,
        ]

        if plot_toggles is None:
            plot_toggles = default_plot_toggles
        self._plot_toggles = plot_toggles

        # ``parameters`` is a matrix of parameters with each "column" specifying the parameters for a single model. Hence
        # we want to iteratre through column-wise and use these to build the ``Model`` class instance. Here, the ``map``
        # function does this tranpose into a column-wise iterable.
        models = [
            Model(*model_parameters, *global_model_parameters, plot_toggles) for model_parameters in map(list, zip(*individual_model_parameters))
        ]
        self._models = models

        # Determine if the stellar mass function needs to be computed for each model. Important we do this before
        # checking ``calculation_functions``.
        for model in models:
            if self._does_smf_need_computing(model):
                model.plot_toggles["SMF"] = True
                plot_toggles["SMF"] = True

        # Then populate the `calculation_methods` dictionary. This dictionary will control
        # which properties each model will calculate.  The dictionary is populated using
        # the plot_toggles defined above.
        # Our functions are inside the `example_calcs.py` module and are named "calc_<toggle>". If
        # your functions are in a different module or different function prefix, change it
        # here.
        # ALL FUNCTIONS MUST HAVE A FUNCTION SIGNATURE `func(Model, gals, optional_kwargs=...)`.
        if calculation_functions is None:
            calculation_functions = generate_func_dict(
                plot_toggles, module_name="sage_analysis.example_calcs", function_prefix="calc_"
            )

        # Because we have adjusted the SMF, check if it's a calculation.
        for model in models:
            # Condition checks for condition where SMF is being compputed but not in ``calculation_functions``.
            if model._plot_toggles.get("SMF", None) and not calculation_functions.get("SMF", None):
                raise ValueError(
                    "The stellar mass function (``SMF``) is being computed, either because it was set manually "
                    "(through ``plot_toggles``) or because another plot requires it (``plots_that_need_smf``).\n"
                    "However, ``calc_SMF`` was not found in ``calculation_functions``. Ensure that it is added."
                )

        if plot_functions is None:
            plot_functions = generate_func_dict(
                plot_toggles, module_name="sage_analysis.example_plots", function_prefix="plot_"
            )
        self._plot_functions = plot_functions

        if galaxy_properties_to_analyse is None:
            galaxy_properties_to_analyse = default_galaxy_properties_to_analyse

        for model in self._models:

            # Read the parameter files and update any of the missing parameters.
            self._read_sage_file(model)

            # Also initialise all of the properties that are required.
            for name, galaxy_properties in galaxy_properties_to_analyse.items():
                for snapshot, _ in enumerate(model._redshifts):
                    self._initialise_properties(name, model, galaxy_properties, snapshot)

            # Finally, set some attributes that are more suited to a per-model basis.
            model._calculation_functions = calculation_functions

            # Go through the calculation functions and pull out those that are actually being analysed over a number of
            # snapshots. Ensure these aren't in ``_calculation_functions`` because otherwise we'd double count.
            history_calculation_functions = {}
            for func_name in self._history_redshifts.keys():
                try:
                    calculation_function = calculation_functions[func_name]
                except KeyError:
                    continue
                history_calculation_functions[func_name] = calculation_function
                del model._calculation_functions[func_name]

            model._history_calculation_functions = history_calculation_functions

            self._set_history_snapshots(model)

            # Based on the snapshots required to analyse over history, we may have to loop over different snapshots.
            history_snaps_to_loop = []
            for property_name in self._history_redshifts.keys():

                # If the plot toggles have been changed, then there's no guarantee that the keys for
                # ``_history_redshifts`` and ``_plot_toggles`` match.
                try:
                    plot_toggle_value = self._plot_toggles[property_name]
                except KeyError:
                    continue

                # Furthermore, maybe plotting has been disabled for this property.
                if not plot_toggle_value:
                    continue

                snaps = getattr(model, f"_history_{property_name}_snaps")
                history_snaps_to_loop.extend(snaps)

            model._history_snaps_to_loop = np.unique(history_snaps_to_loop)
            logger.info(f"Looping through snapshots {model._history_snaps_to_loop}")


    def _set_history_snapshots(self, model: Model) -> None:

        # Maybe there were no history redshifts specified.
        if self._history_redshifts is None:
            self._history_snapshots = None
            return

        # Convert these redshifts into snapshots.
        for property_name, property_redshifts in self._history_redshifts.items():

            if property_redshifts == "All":
                redshifts = model._redshifts
            else:
                redshifts = property_redshifts

            attrname = f"_history_{property_name}_redshifts"
            setattr(model, attrname, redshifts)

            # Find the snapshots that are closest to the requested redshifts.
            property_snaps = [(np.abs(model._redshifts - redshift)).argmin() for redshift in redshifts]

            attrname = f"_history_{property_name}_snaps"
            setattr(model, attrname, property_snaps)
        return

    def _read_sage_file(self, model: Model) -> None:

        # If the format wasn't defined, then attempt to read a default parameter file to determine format.
        if model.sage_output_format is None:
            logger.info(
                f"No SAGE output format specified. Attempting to read ``{model.sage_file}`` and using the format "
                f"specified inside."
            )
            sage_dict = read_generic_sage_params(model.sage_file)

            model.sage_output_format = sage_dict["_output_format"]
            logger.info(f"Using ``{model.sage_output_format}`` output format.")

        # Each SAGE output has a specific class written to read in the data.
        model.data_class = self._output_format_data_classes[model.sage_output_format](model, model.sage_file)

        # The data class has read the SAGE ini file.  Update the model with the parameters
        # read and those specified by the user. We will also log some of these.
        for key, value in model.data_class.sage_model_dict.items():

            # Check if the attribute has already been set to a non-default value.
            try:
                attr_value = getattr(model, key)
            except AttributeError:
                pass
            else:
                if attr_value is not None:
                    continue
            setattr(model, key, value)

            default_messages = {
                "_snapshot": f"Snapshot to analyse not specified; using the final snapshot of the simulation ({value})",
                "_label": f"Label not specified; using the FileNameGalaxies from parameter file ({value})",
                "_first_file_to_analyse": f"First file to analyse not specified; using {value}",
                "_last_file_to_analyse": f"Last file to analyse not specified; using num cores SAGE ran with minus 1 ({value})",
            }

            try:
                logger.info(default_messages[key])
            except KeyError:
                pass

        model.volume = model.data_class.determine_volume_analysed(model)

    def _initialise_properties(
        self,
        name: str,
        model: Model,
        galaxy_properties: Dict[str, Dict[str, Union[str, List[str]]]],
        snapshot: int,
    ) -> None:

            # Properties can be binned (e.g., how many galaxies with mass between 10^8.0
            # and 10^8.1), scatter plotted (e.g., for 1000 galaxies plot the specific star
            # formation rate versus stellar mass) or a single number (e.g., the sum
            # of the star formation rate at a snapshot). Properties can be accessed using
            # `Model.properties["property_name"]`; e.g., `Model.properties["SMF"]`.

            # First let's do the properties binned on stellar mass. The bins themselves can be
            # accessed using `Model.bins["bin_name"]`; e.g., `Model.bins["stellar_mass_bins"]

            allowed_property_types = ["binned", "scatter", "single"]
            if galaxy_properties["type"] not in allowed_property_types:
                raise ValueError(
                    f"Requested to analyse a galaxy property with unkown type.  The galaxy properties were "
                    f"{galaxy_properties} and the only accepted types are {allowed_property_types}."
                )

            if galaxy_properties["type"] == "binned":
                model.init_binned_properties(
                    galaxy_properties["bin_low"],
                    galaxy_properties["bin_high"],
                    galaxy_properties["bin_width"],
                    name,
                    galaxy_properties["property_names"],
                    snapshot,
                )
            elif galaxy_properties["type"] == "scatter":
                model.init_scatter_properties(galaxy_properties["property_names"], snapshot)
            elif galaxy_properties["type"] == "single":
                model.init_single_properties(galaxy_properties["property_names"], snapshot)

            logger.info(f"Initialized galaxy properties {galaxy_properties} for Snapshot {snapshot}")


    def _does_smf_need_computing(self, model: Model) -> bool:

        # Maybe the SMF has already been toggled on.
        try:
            toggle = model._plot_toggles["SMF"]
        except KeyError:
            # Perhaps "SMF" isn't present in the plot toggles.
            pass
        else:
            # "SMF" is present and is turned on -> SMF does need to be computed.
            if toggle:
                return True

        # Determine those plots that are being computed.
        plots = [toggle for toggle, value in model._plot_toggles.items() if value]

        # Then, check if any of these plots need the SMF.
        if any([plot in model._plots_that_need_smf for plot in plots]):
            logger.info(f"One of your plots require the SMF to be calculated. Turning the SMF plot toggle on.")
            return True

        # Otherwise, they don't need the SMF.
        return False


    def analyse_galaxies(self, snapshot: Optional[int] = None) -> None:
        """
        snapshots_to_plot : list of ints, optional
            If not specified, uses the lowest redshift snapshot as specified by the redshift file read from ``sage_file``.
        """

        if self._plot_toggles == {}:
            logger.debug(f"No plot toggles specified.")
            return

        for model in self._models:

            if snapshot is None:
                snapshot = len(model._redshifts) - 1

            model.calc_properties_all_files(model._calculation_functions, snapshot, debug=False)

            # Now handle calculate properties that are tracked over redshift (if any).
            if model._history_snaps_to_loop is None:
                continue

            for snap in model._history_snaps_to_loop:
                model.calc_properties_all_files(
                    model._history_calculation_functions, snap, debug=False, close_file=False
                )

    def generate_plots(
        self,
        snapshot: Optional[int] = None,
        plot_output_format: str = "png",
        plot_output_path: str = "./plots/",
    ) -> Optional[List[matplotlib.figure.Figure]]:

        if self._plot_toggles == {}:
            logger.debug(f"No plot toggles specified.")
            return

        # Check to see if the directory exists. If ``plot_output_path`` is "directory/tag" then we create "directory/".
        if not os.path.exists(os.path.dirname(plot_output_path)):
            os.makedirs(os.path.dirname(plot_output_path))

        # Snapshot needs to be a list to allow plotting different snapshots for different models.
        if snapshot is None:
            snapshot = len(self._models[0]._redshifts) - 1

        # Now do the plotting.
        figs = []

        for func, kwargs in self._plot_functions.values():
            fig = func(
                    self._models,
                    snapshot,
                    plot_output_path,
                    plot_output_format,
                    **kwargs
                )

            if type(fig) == list:
                figs.extend(fig)
            else:
                figs.append(fig)

        return figs
